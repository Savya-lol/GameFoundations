# Gameplay Framework

GameFoundations ships with light-weight gameplay primitives meant to be extended in your project. This page covers abilities, state machines, initiators, and utility helpers.

## Ability System

Namespace: `Darkmatter.Core.Abilities`

- `IAbility` defines `Activate`, `Deactivate`, `Tick`, and the `IsActive` flag.
- `BaseAbilitySystem` inherits from VContainer's `ITickable` and iterates a DI-provided collection of abilities.
- Each ability decides when it is active; the system simply forwards ticks to active ones.

Recommended workflow:

```csharp
public sealed class DashAbility : IAbility
{
    public bool IsActive { get; private set; }

    public void Activate() => IsActive = true;
    public void Deactivate() => IsActive = false;

    public void Tick()
    {
        if (!IsActive) return;
        // Dash logic
    }
}
```

Register abilities and `BaseAbilitySystem` in a lifetime scope so they run automatically.

## State Machine

Namespace: `Darkmatter.Core.Services.StateMachines`

- `BaseStateMachine` encapsulates a stack-based state machine with `Push`, `Pop`, and `Replace`.
- States implement `IState` (`OnEnter`, `OnExit`, `Tick`).
- Use it for layered systems such as gameplay phases, UI screens, or AI brains.

Because `BaseStateMachine` has no update loop built-in, you should call `Current.Tick()` from whatever system owns the machine (e.g., a MonoBehaviour's `Update` or a VContainer `ITickable`).

## Initiators

Namespace: `Darkmatter.Core.Initiators` and `Darkmatter.Core.Services.InitiatorService`

- `CoreInitiator` is an entry-point MonoBehaviour registered via `CoreLifetimeScope.RegisterEntryPoint`.
- On `Start`, it:
  1. Aligns application settings (frame rate, sleep timeout).
  2. Enables `GameInputs`.
  3. Initializes audio and scene loader services.
  4. Adds `CoreAudioClipsSO` to the audio catalog.
- Scene-specific initiators implement `ISceneInitiator` and expose load, start, and exit entry points. They receive an `IInitiatorEnterData` payload when loading.

Guidelines:

- Keep expensive scene setup code inside `LoadEntryPoint` or `StartEntryPoint` implementations rather than `Awake` to maintain deterministic boot order.
- Register initiators in VContainer so they can request dependencies safely.

## Input

- `GameInputs` is auto-generated by the Unity Input System (`Assets/Darkmatter/Core/Plugins/InputSystem/GameInputs.inputactions`).
- `CoreInitiator` enables the input asset during startup; ensure you disable it when leaving play mode or switching contexts if required.
- `Utils/InputUtils.IsPointerOverUI()` shields pointer checks from the specific input backend, helping you write backend-agnostic UI logic.

## Animation Helpers

Source: `Assets/Darkmatter/Core/Scripts/Extensions/AnimatorExtensions.cs`

- `PlayAndWaitAsync` – Plays a state by hash and yields until completion.
- `CrossFadeAndWaitAsync` – Cross-fades and waits for the target state to finish.
- `WaitCurrentStateAsync` – Waits until the active state's normalized time reaches 1.

All helpers return `UniTask`, making them easy to compose inside async sequences or timeline-style scripts.

## Miscellaneous Utilities

- `EncryptionUtils` (AES encrypt/decrypt) underpins the persistence layer but can also secure lightweight payloads.
- `StringExtensions.IsNullOrEmpty` adds an instance-style check for null or empty strings.

Treat these utilities as starting points—swap in custom implementations as your production needs evolve.
